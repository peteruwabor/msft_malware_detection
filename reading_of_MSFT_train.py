import pandas as pd
import numpy  as np 
import io
import multicore
import time

start=time.time()
dataframe=pd.read_csv(filepath_or_buffer="D:\\Documents\\Data Science Certificate\\group_assignment\\microsoft-malware-prediction\\train.csv",sep=",",low_memory=False)
#data_project.info()
end=time.time()
print((end-start)/60)
print("time elapsed :  ",(end-start)/60)
start=time.time()

startingMemoryUsage = dataframe.memory_usage().sum() / 1024**2

print('Dataframe was {:.2f} MB'.format(startingMemoryUsage))

for column in dataframe.columns:
    columnDataType = dataframe[column].dtype

    if columnDataType != object:
        columnMin = dataframe[column].min()
        columnMax = dataframe[column].max()

        if str(columnDataType)[:3] == 'int':
            if columnMin > np.iinfo(np.int8).min and columnMax < np.iinfo(np.int8).max:
                dataframe[column] = dataframe[column].astype(np.int8)
            elif columnMin > np.iinfo(np.int16).min and columnMax < np.iinfo(np.int16).max:
                dataframe[column] = dataframe[column].astype(np.int16)
            elif columnMin > np.iinfo(np.int32).min and columnMax < np.iinfo(np.int32).max:
                dataframe[column] = dataframe[column].astype(np.int32)
            elif columnMin > np.iinfo(np.int64).min and columnMax < np.iinfo(np.int64).max:
                dataframe[column] = dataframe[column].astype(np.int64)  
        else:
            if columnMin > np.finfo(np.float16).min and columnMax < np.finfo(np.float16).max:
                dataframe[column] = dataframe[column].astype(np.float16)
            elif columnMin > np.finfo(np.float32).min and columnMax < np.finfo(np.float32).max:
                dataframe[column] = dataframe[column].astype(np.float32)
            else:
                dataframe[column] = dataframe[column].astype(np.float64)
    else:
        dataframe[column] = dataframe[column].astype('category')

endingingMemoryUsage = dataframe.memory_usage().sum() / 1024**2

print('Dataframe is now: {:.2f} MB'.format(endingingMemoryUsage))

end=time.time()
print((end-start)/60)
print("time elapsed :  ",(end-start)/60)


###############################################################################################################################################################################
#                                                                   DATA CLEANING 
###############################################################################################################################################################################



data_project=dataframe
print("Quantity of computers with a malware infection %7.1f " % data_project['HasDetections'].sum())
print("Quantity  of computers analyzed %7.1f" % data_project['HasDetections'].count())
print("Percentage of problems of the overall machines analyzed %1.3f " % (data_project['HasDetections'].sum()/data_project['HasDetections'].count()))

print(np.sort(data_project.isnull().sum()/data_project.shape[0]))

col_drop=[data_project.columns[i] for i in range(0,data_project.shape[1])  if((data_project.iloc[:,i].isnull().sum()/data_project.shape[0])>=0.3)  ]
print("Columns that are going to be removed",col_drop)

data_project1=data_project.drop(col_drop,axis=1)
data_project1.head(5)


#FILLING VARIABLES  - AS I CORROBORATE WE CAN ERRASE THE RAM PROBLEMS (AS WE COUNT WITH 8.9MM dataset , if we do that we can eliminate the combination of RAM  and processor core count missing)
data_project1[['Census_TotalPhysicalRAM','Census_ProcessorCoreCount','Processor','Census_InternalPrimaryDiagonalDisplaySizeInInches','AVProductsInstalled','Platform']].info()
print(data_project1[['Census_TotalPhysicalRAM','Census_ProcessorCoreCount','Processor','Census_InternalPrimaryDiagonalDisplaySizeInInches','AVProductsInstalled','Platform']].isnull().sum())
print(data_project1[['Census_TotalPhysicalRAM','Census_ProcessorCoreCount','Processor','Census_InternalPrimaryDiagonalDisplaySizeInInches','AVProductsInstalled','Platform']].isnull().sum()/data_project1.shape[0])

# THIS OPTION WAS NOT USED (THE FILLED OF MEMORY)
# THERE IS A CHANCE TO FILL THE AMOUNT OF MEMORY BASE IN : THOSE ARM (ARE TABLETS SO THEY COULD BE BOUND TO THE MORE COMMON TABLET MEMORY, IN THE CASE OF 64 BITS COULD BE ATTACHED TO THE RAM OVER 4 GB INCLUSIVE WITH MORE QUANTITY THE SAME AS X86 (32BITS ) WITH LESS THAN 4 GB - MORE COMMON DATA)

data_project1['Census_TotalPhysicalRAM'][data_project1['Census_TotalPhysicalRAM'].isnull()]
print("almost all the processor core count null are associated with total phisical RAM null: %i " % (data_project1['Census_ProcessorCoreCount'][data_project1['Census_TotalPhysicalRAM'].isnull() ].isnull().sum()))
#this is going to erase the memory missings (there are so a lot of filled with memory so we are just losing 1% of the data with this cleaning)
data_project2=data_project1[data_project1['Census_TotalPhysicalRAM'].isnull()==False] #NAN FILTER FOR MEMORY
print(data_project2[['Census_TotalPhysicalRAM','Census_ProcessorCoreCount','Processor','Census_InternalPrimaryDiagonalDisplaySizeInInches','AVProductsInstalled','Platform']].isnull().sum())
print(data_project2[['Census_TotalPhysicalRAM','Census_ProcessorCoreCount','Processor','Census_InternalPrimaryDiagonalDisplaySizeInInches','AVProductsInstalled','Platform']].isnull().sum()/data_project2.shape[0])
data_project2['Processor'][data_project2['Census_ProcessorCoreCount'].isnull()].unique()


start=time.time()
value_64=np.array((data_project2['Census_ProcessorCoreCount'][(data_project2['Census_ProcessorCoreCount']>4)  * (data_project2['Processor']=='x64') ])).mean()
value_32=np.array((data_project2['Census_ProcessorCoreCount'][(data_project2['Census_ProcessorCoreCount']<=4)  * (data_project2['Processor']=='x86') ])).mean()
value_arm64=np.array((data_project2['Census_ProcessorCoreCount'][ (data_project2['Processor']=='arm64') *  (data_project2['Census_ProcessorCoreCount'].isnull()==False) ])).mean() 

data_project2['ProcessorCoreCount_4missing']=data_project2[['Processor','Census_ProcessorCoreCount']].apply(lambda x: value_64 if  (x.loc['Processor']=='x64') else ( value_32  if ((x.loc['Processor']=='x86') ) else (value_arm64 ) ),axis=1)
end=time.time()

print("elapsed time",(end-start)/60)
#I have to check the results that comes out from the preceding lambda 


data_project2['filled_ProcessorCoreCount']=data_project2[['ProcessorCoreCount_4missing','Census_ProcessorCoreCount']].apply(lambda x: x.loc['ProcessorCoreCount_4missing'] if  (np.isnan(x.loc['Census_ProcessorCoreCount'])) else x.loc['Census_ProcessorCoreCount'],axis=1)

data_project2['filled_ProcessorCoreCount'].isnull().sum()

#THERE IS NO NAN's in this variable
#####################################################################################################################################
# PRIMARY DISK TYPE NAME
#THE PRIMARY DISK WOULD BE IMPORTANT ALSO
data_project2['Census_PrimaryDiskTypeName'] = data_project2['Census_PrimaryDiskTypeName'].replace('Unspecified', 'UNKNOWN')
data_project2['Census_PrimaryDiskTypeName'].unique()

# BE CAREFUL WITH THE NANS HERE , WE NEED TO TRANSFORM IT TO A UNKNOWN  

data_project2['Census_InternalPrimaryDiagonalDisplaySizeInInches'].unique()

data_project2['Census_ProcessorModelIdentifier']

###################################################################################################################################################################################
#THIS PART IS GOING TO BE USED FOR FILL THE MISSINGS IN THE REST OF THE DATA
data_project2['IsProtected'].unique()
data_project2['GeoNameIdentifier'].unique()
data_project2['AVProductStatesIdentifier'].describe()
data_project2['Census_ProcessorModelIdentifier'].describe()

data_project2['CityIdentifier'].fillna(0.0, inplace = True) 
data_project2['OrganizationIdentifier'].fillna(0.0, inplace = True) 
data_project2['GeoNameIdentifier'].fillna(0.0, inplace = True) # the 0.0 means that the data was unknown 
data_project2['IsProtected'].fillna(-1.0, inplace = True) # the -1 means that the data was unknown 
data_project2['IsProtected'].fillna(-1.0, inplace = True)
data_project2['AVProductStatesIdentifier'].fillna(0.0, inplace = True) # the 00 means that the data was unknown
# data_project2['Census_ProcessorCoreCount'].fillna(0.0, inplace = True)
data_project2['Census_OEMNameIdentifier'].fillna(0.0, inplace = True) 
data_project2['Census_OEMModelIdentifier'].fillna(0.0, inplace = True)
data_project2['Census_ProcessorModelIdentifier'].fillna(0.0, inplace = True)# the 0.0 means that the data was unknown
# data_project2['Census_PrimaryDiskTotalCapacity'].fillna(0.0, inplace = True)
# data_project2['Census_SystemVolumeTotalCapacity'].fillna(0.0, inplace = True)
# data_project2['Census_TotalPhysicalRAM'].fillna(0.0, inplace = True)
data_project2['Census_ChassisTypeName'].fillna("0", inplace = True)
data_project2['Census_InternalPrimaryDiagonalDisplaySizeInInches'].fillna(0.0, inplace = True)
data_project2['Census_InternalPrimaryDisplayResolutionHorizontal'].fillna(0.0, inplace = True)
data_project2['Census_InternalPrimaryDisplayResolutionVertical'].fillna(0.0, inplace = True)
data_project2['Census_OSInstallLanguageIdentifier'].fillna(0.0, inplace = True)
data_project2['Census_FirmwareManufacturerIdentifier'].fillna(0.0, inplace = True)
data_project2['Census_FirmwareVersionIdentifier'].fillna(0.0, inplace = True)
data_project2['Wdft_RegionIdentifier'].fillna(0.0, inplace = True)


############################################################################################################
# CHASIS TYPE NAMES 

data_project2['Census_ChassisTypeName'] = data_project2['Census_ChassisTypeName'].replace(['0', '30', '35', '31', '88', '32', '127', '25', '44', '36', '81', '28', '112', '39', '45', '49', '82', '76'],['UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN', 'UNKNOWN'])


############################################################################################################
# Census_PowerPlatformRoleName - Replace null values with "UNKNOWN"

data_project2['Census_PowerPlatformRoleName'].fillna("UNKNOWN", inplace = True) 
data_project2['Census_PowerPlatformRoleName'] = data_project2['Census_PowerPlatformRoleName'].replace("Unspecified", "UNKNOWN")

##############################################################################################################


data_project2['AVProductsInstalled'].fillna(data_project2['AVProductsInstalled'].value_counts().sort_values(ascending=False).index[0], inplace = True) 
data_project2['AVProductsEnabled'].fillna(data_project2['AVProductsEnabled'].value_counts().sort_values(ascending=False).index[0], inplace = True) 
data_project2['OsBuildLab'].fillna(data_project2['OsBuildLab'].value_counts().sort_values(ascending=False).index[0], inplace = True) 
data_project2['SMode'].fillna(data_project2['SMode'].value_counts().sort_values(ascending=False).index[0], inplace = True) 
data_project2['Firewall'].fillna(data_project2['Firewall'].value_counts().sort_values(ascending=False).index[0], inplace = True) 
data_project2['Census_ProcessorManufacturerIdentifier'].fillna(data_project2['Census_ProcessorManufacturerIdentifier'].value_counts().sort_values(ascending=False).index[0], inplace = True) 
#data_project2['Census_PrimaryDiskTypeName'].fillna(data_project2['Census_PrimaryDiskTypeName'].value_counts().sort_values(ascending=False).index[0], inplace = True) 
data_project2['Census_PrimaryDiskTotalCapacity'].fillna(data_project2['Census_PrimaryDiskTotalCapacity'].value_counts().sort_values(ascending=False).index[0], inplace = True) 
data_project2['Census_SystemVolumeTotalCapacity'].fillna(data_project2['Census_SystemVolumeTotalCapacity'].value_counts().sort_values(ascending=False).index[0], inplace = True) 
data_project2['Census_HasOpticalDiskDrive'].fillna(data_project2['Census_HasOpticalDiskDrive'].value_counts().sort_values(ascending=False).index[0], inplace = True) 
data_project2['Census_IsFlightsDisabled'].fillna(data_project2['Census_IsFlightsDisabled'].value_counts().sort_values(ascending=False).index[0], inplace = True) 
data_project2['Census_IsAlwaysOnAlwaysConnectedCapable'].fillna(data_project2['Census_IsAlwaysOnAlwaysConnectedCapable'].value_counts().sort_values(ascending=False).index[0], inplace = True) 
data_project2['Census_IsVirtualDevice'].fillna(data_project2['Census_IsVirtualDevice'].value_counts().sort_values(ascending=False).index[0], inplace = True) 
data_project2['Wdft_IsGamer'].fillna(data_project2['Wdft_IsGamer'].value_counts().sort_values(ascending=False).index[0], inplace = True) 
data_project2['Census_InternalBatteryNumberOfCharges'].fillna(data_project2['Census_InternalBatteryNumberOfCharges'].value_counts().sort_values(ascending=False).index[0], inplace = True) 

#################################################################################################################

data_project2['RtpStateBitfield'].fillna(1.0, inplace = True) 
data_project2['RtpStateBitfield'] = data_project2['RtpStateBitfield'].replace([3.0, 5.0, 7.0, 8.0, 35.0], [1.0, 1.0, 1.0, 1.0, 1.0])


###################################################################################################################
# UacLuaenable - Replace null and non-zero values with 1

data_project2['UacLuaenable'].fillna(1.0, inplace = True) 
data_project2['UacLuaenable'] = data_project2['UacLuaenable'].replace([48.0, 2.0, 49.0, 6357062.0, 3.0, 5.0, 16777216.0, 7798884.0, 255.0], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])

#######################################################################################################################
#                                                    NEW VARIABLES 
###############################################################################################################################



# ALSO WERE SO IMPORTANT THE GAMING CAPABILITIES AND THE PRIMARY DISK CAPACITY

###############################################################################################################################################
# NEW VARIABLES 

data_project2['DANGEROUS_RAM_INSTALLED']=data_project2[['Census_TotalPhysicalRAM']].apply(lambda x: 1 if (x['Census_TotalPhysicalRAM']<=(1024*16) and (1024*4)<x['Census_TotalPhysicalRAM'])  else 0,axis=1)

data_project2['DANGEROUS_PROCESSOR_INSTALLED']=data_project2[['filled_ProcessorCoreCount']].apply(lambda x: 1 if (x['filled_ProcessorCoreCount']<=32 and 3<x['filled_ProcessorCoreCount']) else 0,axis=1)
    
data_project2['DANGEROUS_PROCESSOR_TYPE_INSTALLED']=data_project2[['Processor']].apply(lambda x: 1 if (x['Processor']=='x64') else 0,axis=1)

data_project2['DANGEROUS_DISPLAY_SIZE']=data_project2[['Census_InternalPrimaryDiagonalDisplaySizeInInches']].apply(lambda x: 1 if (x['Census_InternalPrimaryDiagonalDisplaySizeInInches']<=60 and x['Census_InternalPrimaryDiagonalDisplaySizeInInches']>=17 ) else 0,axis=1)

data_project2['HIGH_END_COMPUTER']=data_project2[['DANGEROUS_RAM_INSTALLED','DANGEROUS_PROCESSOR_INSTALLED','DANGEROUS_DISPLAY_SIZE']].apply(lambda x: 1 if (x['DANGEROUS_RAM_INSTALLED']==1 and  x['DANGEROUS_PROCESSOR_INSTALLED']==1) else 0,axis=1)


###################################################################################################################
# SECURITY RELATED

data_project2['HAS_ONLY_ONE_AV']=data_project2[['AVProductsInstalled']].apply(lambda x: 1 if (x['AVProductsInstalled']==1 ) else 0,axis=1)


data_project2['HAS_AN_OS_WSUPPORT']=data_project2[['Platform']].apply(lambda x: 1 if (x['Platform']=='windows10' or x['Platform']=='windows8' ) else 0,axis=1)

##########################################################################################################################################################################################

#REVISION

print(data_project2.isnull().sum()/data_project2.shape[0])

print("max number of null categories caught",max(data_project2.isnull().sum()))

def print_full(df):
    pd.set_option('display.max_rows', len(df))
    print(df)
    pd.reset_option('display.max_rows')



data_project2['Census_ProcessorModelIdentifier']
data_project2['Census_PrimaryDiskTotalCapacity'] # It could be filled with the mean or the most common capacity 
data_project2['Census_SystemVolumeTotalCapacity']# This could be at much the number declare in Census_PrimaryDiskTotalCapacity. (it depends on disk total capacity and usage)
#there should be note that the amount of missings of both variables is almost the same. So the way that they are going to be filled must be similar. (they could be removed also but we removed 1% of the data)
data_project2['Census_PrimaryDiskTotalCapacity'].isnull().sum()
data_project2['Census_SystemVolumeTotalCapacity'].isnull().sum()


print(data_project2.columns[data_project2.isnull().sum()>0])
data_project3=data_project2.drop('Census_ProcessorCoreCount',axis=1)

print(data_project3.columns[data_project3.isnull().sum()>0])

########################################################################################################################################################################
#                                              MODEL SELECTOR                                   
########################################################################################################################################################################
import sklearn
from sklearn.model_selection import train_test_split
from sklearn import model_selection
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
from sklearn.metrics import accuracy_score
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
from sklearn.naive_bayes import GaussianNB
from sklearn.svm import SVC


x= data_project3.loc[:,'insert feature columns'] # This part is still incomplete
y= data_project3.loc[:, 'insert target column we are trying to predict']#This part is still incomplete

validation_size = 0.30
seed = 7
scoring = 'accuracy'
x_train,x_test,y_train,y_test= train_test_split(x,y,test_size=validation_size, random_state=seed)

# Spot check algorithms to see which is better
models =[]
models.append(('LR', LogisticRegression()))
models.append(('LDA', LinearDiscriminantAnalysis()))
models.append(('KNN', KNeighborsClassifier()))
models.append(('CART', DecisionTreeClassifier()))
models.append(('NB', GaussianNB()))

#evaluate each model in turn
results =[]
names =[]
for name, model in models:
    kfold = model_selection.KFold(n_splits=10, random_state=10)
    cv_results = model_selection.cross_val_score(model, x_train, y_train, cv=kfold, scoring=scoring)
    results.append(cv_results)
    names.append(name)
    msg= "%s: %f(%f)" %(name, cv_results.mean(), cv_results.std())
    print(msg)
    
#this should give you the accuracies for each model so from there we can select the best performing one




########################################################################################################################################################################
#                                              UNIVARIATE ANALISYS                                   
########################################################################################################################################################################

# RELEASE MEMORY 
import gc
gc.collect()

#######################################################
# GINI AND WOE 







